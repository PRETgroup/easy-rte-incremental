package rtec

import (
	"text/template"

	"github.com/PRETgroup/goFB/goFB/stconverter"
)

const rteVerilogParallelCompositionTemplate = `
{{define "functionVerilog"}}{{$block := index .Functions .FunctionIndex}}{{$blocks := .Functions}}{{$pbfPolicies := getAllPolicyEnfInfo $block}}
//This file should be called F_{{$block.Name}}.sv
//This is autogenerated code. Edit by hand at your peril!!!

//Warning: This is experimental parallel composition code.

{{range $polI, $pol := $block.Policies}}
	module F_combinatorialVerilog_{{$block.Name}}_policy_{{$pol.Name}} (
		input wire clk,

		//inputs (plant to controller){{range $index, $var := $block.InputVars}}
		input wire {{getVerilogWidthArrayForType $var.Type}} {{$var.Name}}_ptc_in,
		output reg {{getVerilogWidthArrayForType $var.Type}} {{$var.Name}}_ptc_out,
		output reg {{getVerilogWidthArrayForType $var.Type}} {{$var.Name}}_dont_care,
		{{end}}
		//outputs (controller to plant){{range $index, $var := $block.OutputVars}}
		input wire {{getVerilogWidthArrayForType $var.Type}} {{$var.Name}}_ctp_in,
		output reg {{getVerilogWidthArrayForType $var.Type}} {{$var.Name}}_ctp_out,
		output reg {{getVerilogWidthArrayForType $var.Type}} {{$var.Name}}_dont_care,
		{{end}}

		//helpful internal variable outputs {{range $vari, $var := $pol.InternalVars}}{{if not $var.Constant}}
		output wire {{getVerilogWidthArrayForType $var.Type}} {{$var.Name}}_out,
		{{end}}{{end}}
		
		//helpful state output input var{{if $polI}},
		{{end}}
		output reg {{getVerilogWidthArray (add (len $pol.States) 1)}} {{$block.Name}}_policy_{{$pol.Name}}_state_out

		);


		//For each policy, we need define types for the state machines
		localparam
			{{if len $pol.States}}{{range $index, $state := $pol.States}}` + `POLICY_STATE_{{$block.Name}}_{{$pol.Name}}_{{$state}} = {{$index}},
			{{end}}{{else}}POLICY_STATE_{{$block.Name}}_{{$pol.Name}}_unknown 0 {{end}}` + `POLICY_STATE_{{$block.Name}}_{{$pol.Name}}_violation = {{if len $pol.States}}{{len $pol.States}};{{else}}1;{{end}}

		//For each policy, we need a reg for the state machine
		reg {{getVerilogWidthArray (add (len $pol.States) 1)}} {{$block.Name}}_policy_{{$pol.Name}}_c_state = 0;
		reg {{getVerilogWidthArray (add (len $pol.States) 1)}} {{$block.Name}}_policy_{{$pol.Name}}_n_state = 0;

		{{range $index, $var := $block.InputVars}}
		{{getVerilogType $var.Type}}{{$var.Name}} {{if $var.InitialValue}}/* = {{$var.InitialValue}}*/{{else}}= 0{{end}};
		{{end}}{{range $index, $var := $block.OutputVars}}
		{{getVerilogType $var.Type}}{{$var.Name}} {{if $var.InitialValue}}/* = {{$var.InitialValue}}*/{{else}}= 0{{end}};
		{{end}}
		{{$pfbEnf := index $pbfPolicies $polI}}{{if not $pfbEnf}}//Policy is broken!{{else}}//internal vars
		{{range $vari, $var := $pfbEnf.OutputPolicy.InternalVars}}{{if $var.Constant}}wire {{getVerilogWidthArrayForType $var.Type}} {{$var.Name}} = {{$var.InitialValue}}{{else}}{{getVerilogType $var.Type}} {{$var.Name}} = 0{{if $var.InitialValue}}/* = {{$var.InitialValue}}*/{{end}}{{end}};
		{{end}}{{end}}

		initial begin{{range $index, $var := $block.InputVars}}
			{{getVerilogWidthArrayForType $var.Type}} {{$var.Name}}_ptc_out = 0;
			{{getVerilogWidthArrayForType $var.Type}} {{$var.Name}}_dont_care = 0;
		{{end}}{{range $index, $var := $block.OutputVars}}
			{{getVerilogWidthArrayForType $var.Type}} {{$var.Name}}_ctp_out = 0;
			{{getVerilogWidthArrayForType $var.Type}} {{$var.Name}}_dont_care = 0;
		{{end}}
		end

		always @(posedge clk)
		begin
			{{$block.Name}}_policy_{{$pol.Name}}_c_state = {{$block.Name}}_policy_{{$pol.Name}}_n_state;

			//increment timers/clocks
			{{$pfbEnf := index $pbfPolicies $polI}}{{if not $pfbEnf}}//Policy is broken!{{else}}//internal vars
			{{range $vari, $var := $pfbEnf.OutputPolicy.InternalVars}}{{if not $var.Constant}}{{$var.Name}} = {{$var.Name}}{{if $var.IsDTimer}} + 1{{end}};{{end}}
			{{end}}{{end}}
		end

		always @* begin
			// Default no location change
			{{$block.Name}}_policy_{{$pol.Name}}_n_state = {{$block.Name}}_policy_{{$pol.Name}}_c_state;
			
			// Default no change to inputs/outputs (transparency) {{range $index, $var := $block.InputVars}}
			{{$var.Name}} = {{$var.Name}}_ptc_in;
			{{end}}
			{{range $index, $var := $block.OutputVars}}{{$var.Name}} = {{$var.Name}}_ctp_in;
			{{end}}

			{{if $block.Policies}}//input policies
			{{$pfbEnf := index $pbfPolicies $polI}}
			{{if not $pfbEnf}}//{{$pol.Name}} is broken!
			{{else}}{{/* this is where the policy comes in */}}	//INPUT POLICY {{$pol.Name}} BEGIN 
				case({{$block.Name}}_policy_{{$pol.Name}}_c_state)
					{{range $sti, $st := $pol.States}}` + `POLICY_STATE_{{$block.Name}}_{{$pol.Name}}_{{$st.Name}}: begin
						{{range $tri, $tr := $pfbEnf.InputPolicy.GetViolationTransitions}}{{if eq $tr.Source $st.Name}}{{/*
						*/}}
						if ({{$cond := getVerilogECCTransitionCondition $block (compileExpression $tr.STGuard)}}{{$cond.IfCond}}) begin
							//transition {{$tr.Source}} -> {{$tr.Destination}} on {{$tr.Condition}}
							//select a transition to solve the problem
							{{$solution := $pfbEnf.SolveViolationTransition $tr true}}
							{{if $solution.Comment}}//{{$solution.Comment}}{{end}}
							{{range $soleI, $sole := $solution.Expressions}}{{$sol := getVerilogECCTransitionCondition $block (compileExpression $sole)}}{{$sol.IfCond}};
							{{end}}
						end{{end}}{{end}}
					end
					{{end}}
				endcase
			{{end}}
			//INPUT POLICY {{$pol.Name}} END{{end}}

			//output policies
			{{if not $pfbEnf}}//{{$pol.Name}} is broken!
			{{else}}{{/* this is where the policy comes in */}}	//OUTPUT POLICY {{$pol.Name}} BEGIN 
				
				case({{$block.Name}}_policy_{{$pol.Name}}_c_state)
					{{range $sti, $st := $pol.States}}` + `POLICY_STATE_{{$block.Name}}_{{$pol.Name}}_{{$st.Name}}: begin
						{{range $tri, $tr := $pfbEnf.OutputPolicy.GetViolationTransitions}}{{if eq $tr.Source $st.Name}}{{/*
						*/}}
						if ({{$cond := getVerilogECCTransitionCondition $block (compileExpression $tr.STGuard)}}{{$cond.IfCond}}) begin
							//transition {{$tr.Source}} -> {{$tr.Destination}} on {{$tr.Condition}}
							//select a transition to solve the problem
							{{$solution := $pfbEnf.SolveViolationTransition $tr false}}
							{{if $solution.Comment}}//{{$solution.Comment}}{{end}}
							{{range $soleI, $sole := $solution.Expressions}}{{$sol := getVerilogECCTransitionCondition $block (compileExpression $sole)}}{{$sol.IfCond}};
							{{end}}
						end {{end}}{{end}}
					end
					{{end}}
				endcase

				//transTaken_{{$block.Name}}_policy_{{$pol.Name}} = 0;
				//select transition to advance state
				case({{$block.Name}}_policy_{{$pol.Name}}_c_state)
					{{range $sti, $st := $pol.States}}` + `POLICY_STATE_{{$block.Name}}_{{$pol.Name}}_{{$st.Name}}: begin
						{{range $tri, $tr := $pfbEnf.OutputPolicy.GetTransitionsForSource $st.Name}}{{/*
						*/}}
						{{if $tri}}else {{end}}if ({{$cond := getVerilogECCTransitionCondition $block (compileExpression $tr.STGuard)}}{{$cond.IfCond}}) begin
							//transition {{$tr.Source}} -> {{$tr.Destination}} on {{$tr.Condition}}
							{{$block.Name}}_policy_{{$pol.Name}}_n_state = ` + `POLICY_STATE_{{$block.Name}}_{{$pol.Name}}_{{$tr.Destination}};
							//set expressions
							{{range $exi, $ex := $tr.Expressions}}
							{{$ex.VarName}} = {{$ex.Value}};{{end}}
							//transTaken_{{$block.Name}}_policy_{{$pol.Name}} = 1;
						end {{end}} else begin
							//only possible in a violation
							{{$block.Name}}_policy_{{$pol.Name}}_n_state = ` + `POLICY_STATE_{{$block.Name}}_{{$pol.Name}}_violation;
							//transTaken_{{$block.Name}}_policy_{{$pol.Name}} = 1;
						end
					end
					{{end}}
					default begin
						//if we are here, we're in the violation state
						//the violation state permanently stays in violation
						{{$block.Name}}_policy_{{$pol.Name}}_n_state = ` + `POLICY_STATE_{{$block.Name}}_{{$pol.Name}}_violation;
						//transTaken_{{$block.Name}}_policy_{{$pol.Name}} = 1;
					end
				endcase
			{{end}}
			//OUTPUT POLICY {{$pol.Name}} END

			// Ground all signals the enf doesnt care about
			// Inputs{{range $index, $var := $block.InputVars}}
			if ({{$var.Name}} === {{$var.Name}}_ptc_in) begin
				{{$var.Name}}_dont_care <= 1;
				{{$var.Name}} = 0;
			end else begin
				{{$var.Name}}_dont_care <= 0;
			end
			{{end}}
			// Outputs{{range $index, $var := $block.OutputVars}}
			if ({{$var.Name}} === {{$var.Name}}_ctp_in) begin
				{{$var.Name}}_dont_care <= 1;
				{{$var.Name}} = 0;
			end else begin
				{{$var.Name}}_dont_care <= 0;
			end
			{{end}}
			// Post input enforced 
			{{range $index, $var := $block.InputVars}}{{$var.Name}}_ptc_out = {{$var.Name}};
			{{end}}
			// Post output enforced 
			{{range $index, $var := $block.OutputVars}}{{$var.Name}}_ctp_out = {{$var.Name}};
			{{end}}
		end

		//emit state/time inputs
		assign {{$block.Name}}_policy_{{$pol.Name}}_state_out =  {{$block.Name}}_policy_{{$pol.Name}}_c_state;
		{{$pfbEnf := index $pbfPolicies $polI}}{{if not $pfbEnf}}//Policy is broken!{{else}}//internal vars
		{{range $vari, $var := $pfbEnf.OutputPolicy.InternalVars}}{{if not $var.Constant}}assign {{$var.Name}}_out = {{$var.Name}};{{end}}
		{{end}}{{end}}

	endmodule

	{{end}}

// Merge blocks for each input and output
//merge inputs (plant to controller){{range $index, $var := $block.InputVars}}
module merge_{{$var.Name}} (
		input wire {{$var.Name}}_ptc_in, // original environment signal
		input wire [{{(subtract (len $block.Policies) 1)}}:0] {{$var.Name}}_ptc_enf,
		input wire [{{(subtract (len $block.Policies) 1)}}:0] {{$var.Name}}_dont_care_enf,
		output reg {{$var.Name}}_enf_combined,
		output reg {{$var.Name}}_none_care,
		output reg {{$var.Name}}_ptc_out_final
	);
	initial begin
		{{$var.Name}}_enf_combined = 0;
		{{$var.Name}}_none_care = 0;
		{{$var.Name}}_ptc_out_final = 0;
	end

	always@({{$var.Name}}_ptc_enf, {{$var.Name}}_dont_care_enf) begin
		// OR all enforcer output
		{{$var.Name}}_enf_combined <= |{{$var.Name}}_ptc_enf;
		
		// AND the don't cares (to figure out if none care)
		{{$var.Name}}_none_care <= &{{$var.Name}}_dont_care_enf;

	end

	reg {{$var.Name}}_env_delay;
	reg {{$var.Name}}_env_delay_2;
	always @({{$var.Name}}_ptc_in) begin
		{{$var.Name}}_env_delay <= {{$var.Name}}_ptc_in;
	end
	always @({{$var.Name}}_env_delay) begin
		{{$var.Name}}_env_delay_2 <= {{$var.Name}}_env_delay;
	end

	// Mux to select original if none care
	always @({{$var.Name}}_enf_combined, {{$var.Name}}_none_care, {{$var.Name}}_env_delay_2) begin
		{{$var.Name}}_ptc_out_final <= ({{$var.Name}}_none_care)? {{$var.Name}}_env_delay_2: {{$var.Name}}_enf_combined;
	end

endmodule
{{end}}

//merge outputs (controller to plant){{range $index, $var := $block.OutputVars}}
module merge_{{$var.Name}} (
		input wire {{$var.Name}}_ctp_in, // original environment signal
		input wire [{{(subtract (len $block.Policies) 1)}}:0] {{$var.Name}}_ctp_enf,
		input wire [{{(subtract (len $block.Policies) 1)}}:0] {{$var.Name}}_dont_care_enf,
		output reg {{$var.Name}}_enf_combined,
		output reg {{$var.Name}}_none_care,
		output reg {{$var.Name}}_ctp_out_final
	);

	initial begin
		{{$var.Name}}_enf_combined = 0;
		{{$var.Name}}_none_care = 0;
		{{$var.Name}}_ctp_out_final = 0;
	end

	always@({{$var.Name}}_ctp_enf, {{$var.Name}}_dont_care_enf)	begin
		// OR all enforcer output
		{{$var.Name}}_enf_combined <= |{{$var.Name}}_ctp_enf;
		
		// AND the don't cares (to figure out if none care)
		{{$var.Name}}_none_care <= &{{$var.Name}}_dont_care_enf;

	end

	reg {{$var.Name}}_env_delay;
	reg {{$var.Name}}_env_delay_2;
	always @({{$var.Name}}_ctp_in) begin
		{{$var.Name}}_env_delay <= {{$var.Name}}_ctp_in;
	end
	always @({{$var.Name}}_env_delay) begin
		{{$var.Name}}_env_delay_2 <= {{$var.Name}}_env_delay;
	end

	// Mux to select original if none care
	always @({{$var.Name}}_enf_combined, {{$var.Name}}_none_care, {{$var.Name}}_env_delay_2) begin
		{{$var.Name}}_ctp_out_final <= ({{$var.Name}}_none_care)? {{$var.Name}}_env_delay_2: {{$var.Name}}_enf_combined;
	end

endmodule
{{end}}

module {{$block.Name}}_top_level(

		//inputs (plant to controller){{range $index, $var := $block.InputVars}}
		{{$var.Name}}_ptc,
		OUTPUT_{{$var.Name}}_ptc_enf_final,{{end}}
		
		//outputs (controller to plant){{range $index, $var := $block.OutputVars}}
		{{$var.Name}}_ctp,
		OUTPUT_{{$var.Name}}_ctp_enf_final,{{end}}
		
		//helper outputs{{range $polI, $pol := $block.Policies}}{{range $vari, $var := $pol.InternalVars}}{{if not $var.Constant}}
		{{$var.Name}}_out,
		{{end}}{{end}}{{if $polI}}{{end}}{{$block.Name}}_policy_{{$pol.Name}}_state_out,{{end}}

		clk
	);

	input wire clk;
	{{range $index, $var := $block.InputVars}}
	input wire {{$var.Name}}_ptc;
	wire [{{(subtract (len $block.Policies) 1)}}:0] {{$var.Name}}_ptc_enf;
	wire [{{(subtract (len $block.Policies) 1)}}:0] {{$var.Name}}_dont_care_enf;
	wire OUTPUT_{{$var.Name}}_enf_combined;
	wire OUTPUT_{{$var.Name}}_none_care;
	output wire OUTPUT_{{$var.Name}}_ptc_enf_final;{{end}}

	{{range $index, $var := $block.OutputVars}}
	input wire {{$var.Name}}_ctp;
	wire [{{(subtract (len $block.Policies) 1)}}:0] {{$var.Name}}_ctp_enf;
	wire [{{(subtract (len $block.Policies) 1)}}:0] {{$var.Name}}_dont_care_enf;
	wire OUTPUT_{{$var.Name}}_enf_combined;
	wire OUTPUT_{{$var.Name}}_none_care;
	output wire OUTPUT_{{$var.Name}}_ctp_enf_final;
	{{end}}

	//helper outputs{{range $polI, $pol := $block.Policies}}{{range $vari, $var := $pol.InternalVars}}{{if not $var.Constant}}
	output wire {{getVerilogWidthArrayForType $var.Type}} {{$var.Name}}_out;
	{{end}}{{end}}{{if $polI}}{{end}}output wire {{getVerilogWidthArray (add (len $pol.States) 1)}} {{$block.Name}}_policy_{{$pol.Name}}_state_out;{{end}}
	
	{{range $index, $var := $block.InputVars}}merge_{{$var.Name}} instance_merge_{{$var.Name}}(
		.{{$var.Name}}_ptc_in({{$var.Name}}_ptc),
		.{{$var.Name}}_ptc_enf({{$var.Name}}_ptc_enf),
		.{{$var.Name}}_dont_care_enf({{$var.Name}}_dont_care_enf),
		.{{$var.Name}}_enf_combined(OUTPUT_{{$var.Name}}_enf_combined),
		.{{$var.Name}}_none_care(OUTPUT_{{$var.Name}}_none_care),
		.{{$var.Name}}_ptc_out_final(OUTPUT_{{$var.Name}}_ptc_enf_final)
	);
	{{end}}
	{{range $index, $var := $block.OutputVars}}merge_{{$var.Name}} instance_merge_{{$var.Name}}(
		.{{$var.Name}}_ctp_in({{$var.Name}}_ctp),
		.{{$var.Name}}_ctp_enf({{$var.Name}}_ctp_enf),
		.{{$var.Name}}_dont_care_enf({{$var.Name}}_dont_care_enf),
		.{{$var.Name}}_enf_combined(OUTPUT_{{$var.Name}}_enf_combined),
		.{{$var.Name}}_none_care(OUTPUT_{{$var.Name}}_none_care),
		.{{$var.Name}}_ctp_out_final(OUTPUT_{{$var.Name}}_ctp_enf_final)
	);
	{{end}}

	{{range $polI, $pol := $block.Policies}}
	F_combinatorialVerilog_{{$block.Name}}_policy_{{$pol.Name}} instance_policy_{{$pol.Name}}(
		.clk(clk),
		{{range $index, $var := $block.InputVars}}
		.{{$var.Name}}_ptc_in({{$var.Name}}_ptc),
		.{{$var.Name}}_ptc_out({{$var.Name}}_ptc_enf[{{$polI}}]),
		.{{$var.Name}}_dont_care({{$var.Name}}_dont_care_enf[{{$polI}}]),
		{{end}}{{range $index, $var := $block.OutputVars}}
		.{{$var.Name}}_ctp_in({{$var.Name}}_ctp),
		.{{$var.Name}}_ctp_out({{$var.Name}}_ctp_enf[{{$polI}}]),
		.{{$var.Name}}_dont_care({{$var.Name}}_dont_care_enf[{{$polI}}]),
		{{end}}{{range $vari, $var := $pol.InternalVars}}{{if not $var.Constant}}
		.{{$var.Name}}_out({{$var.Name}}_out),
		{{end}}{{end}}
		{{if $polI}}{{end}}.{{$block.Name}}_policy_{{$pol.Name}}_state_out({{$block.Name}}_policy_{{$pol.Name}}_state_out)
		);
	{{end}}
	
endmodule

{{end}}


`

var verilogParallelCompositionTemplateFuncMap = template.FuncMap{
	"getVerilogECCTransitionCondition": getVerilogECCTransitionCondition,
	"getVerilogType":                   getVerilogType,
	"getPolicyEnfInfo":                 getPolicyEnfInfo,
	"getAllPolicyEnfInfo":              getAllPolicyEnfInfo,
	"getVerilogWidthArray":             getVerilogWidthArray,
	"getVerilogWidthArrayForType":      getVerilogWidthArrayForType,
	"add1IfClock":                      add1IfClock,

	"compileExpression": stconverter.VerilogCompileExpression,

	"add":      add,
	"subtract": subtract,
	"equal":    equal,
}

var verilogParallelCompositionTemplates = template.Must(template.New("").Funcs(verilogParallelCompositionTemplateFuncMap).Parse(rteVerilogParallelCompositionTemplate))
